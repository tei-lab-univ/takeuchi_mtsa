/*
 * generated by Xtext 2.25.0
 */
package tau.smlab.syntech.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tau.smlab.syntech.services.SpectraGrammarAccess;
import tau.smlab.syntech.spectra.BinaryRegExp;
import tau.smlab.syntech.spectra.BooleanTerm;
import tau.smlab.syntech.spectra.CompRegExp;
import tau.smlab.syntech.spectra.Constant;
import tau.smlab.syntech.spectra.Counter;
import tau.smlab.syntech.spectra.Define;
import tau.smlab.syntech.spectra.DefineArray;
import tau.smlab.syntech.spectra.DefineDecl;
import tau.smlab.syntech.spectra.DefineRegExp;
import tau.smlab.syntech.spectra.DefineRegExpDecl;
import tau.smlab.syntech.spectra.DomainVarDecl;
import tau.smlab.syntech.spectra.EXGar;
import tau.smlab.syntech.spectra.Import;
import tau.smlab.syntech.spectra.LTLAsm;
import tau.smlab.syntech.spectra.LTLGar;
import tau.smlab.syntech.spectra.Model;
import tau.smlab.syntech.spectra.Monitor;
import tau.smlab.syntech.spectra.Pattern;
import tau.smlab.syntech.spectra.PatternParam;
import tau.smlab.syntech.spectra.PatternParamList;
import tau.smlab.syntech.spectra.Predicate;
import tau.smlab.syntech.spectra.QuantifierExpr;
import tau.smlab.syntech.spectra.RegExp;
import tau.smlab.syntech.spectra.SizeDefineDecl;
import tau.smlab.syntech.spectra.SpectraPackage;
import tau.smlab.syntech.spectra.Subrange;
import tau.smlab.syntech.spectra.TemporalAdditiveExpr;
import tau.smlab.syntech.spectra.TemporalAndExpr;
import tau.smlab.syntech.spectra.TemporalBinaryExpr;
import tau.smlab.syntech.spectra.TemporalIffExpr;
import tau.smlab.syntech.spectra.TemporalImpExpr;
import tau.smlab.syntech.spectra.TemporalInExpr;
import tau.smlab.syntech.spectra.TemporalMultiplicativeExpr;
import tau.smlab.syntech.spectra.TemporalOrExpr;
import tau.smlab.syntech.spectra.TemporalPrimaryExpr;
import tau.smlab.syntech.spectra.TemporalRelationalExpr;
import tau.smlab.syntech.spectra.TemporalRemainderExpr;
import tau.smlab.syntech.spectra.TemporalUnaryExpr;
import tau.smlab.syntech.spectra.Trigger;
import tau.smlab.syntech.spectra.TypeConstant;
import tau.smlab.syntech.spectra.TypeDef;
import tau.smlab.syntech.spectra.TypedParam;
import tau.smlab.syntech.spectra.TypedParamList;
import tau.smlab.syntech.spectra.UnaryRegExp;
import tau.smlab.syntech.spectra.ValueInRange;
import tau.smlab.syntech.spectra.Var;
import tau.smlab.syntech.spectra.VarDecl;
import tau.smlab.syntech.spectra.VarType;
import tau.smlab.syntech.spectra.WeightDef;

@SuppressWarnings("all")
public class SpectraSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpectraGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpectraPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpectraPackage.BINARY_REG_EXP:
				sequence_BinaryRegExp(context, (BinaryRegExp) semanticObject); 
				return; 
			case SpectraPackage.BOOLEAN_TERM:
				sequence_BooleanTerm(context, (BooleanTerm) semanticObject); 
				return; 
			case SpectraPackage.COMP_REG_EXP:
				sequence_CompRegExp(context, (CompRegExp) semanticObject); 
				return; 
			case SpectraPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case SpectraPackage.COUNTER:
				sequence_Counter(context, (Counter) semanticObject); 
				return; 
			case SpectraPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_ARRAY:
				sequence_DefineArray(context, (DefineArray) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_DECL:
				sequence_DefineDecl(context, (DefineDecl) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_REG_EXP:
				sequence_DefineRegExp(context, (DefineRegExp) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_REG_EXP_DECL:
				sequence_DefineRegExpDecl(context, (DefineRegExpDecl) semanticObject); 
				return; 
			case SpectraPackage.DOMAIN_VAR_DECL:
				sequence_DomainVarDecl(context, (DomainVarDecl) semanticObject); 
				return; 
			case SpectraPackage.EX_GAR:
				sequence_EXGar(context, (EXGar) semanticObject); 
				return; 
			case SpectraPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SpectraPackage.LTL_ASM:
				sequence_LTLAsm(context, (LTLAsm) semanticObject); 
				return; 
			case SpectraPackage.LTL_GAR:
				sequence_LTLGar(context, (LTLGar) semanticObject); 
				return; 
			case SpectraPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SpectraPackage.MONITOR:
				sequence_Monitor(context, (Monitor) semanticObject); 
				return; 
			case SpectraPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case SpectraPackage.PATTERN_PARAM:
				sequence_PatternParam(context, (PatternParam) semanticObject); 
				return; 
			case SpectraPackage.PATTERN_PARAM_LIST:
				sequence_PatternParamList(context, (PatternParamList) semanticObject); 
				return; 
			case SpectraPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case SpectraPackage.QUANTIFIER_EXPR:
				sequence_QuantifierExpr(context, (QuantifierExpr) semanticObject); 
				return; 
			case SpectraPackage.REG_EXP:
				sequence_PrimaryRegExp(context, (RegExp) semanticObject); 
				return; 
			case SpectraPackage.SIZE_DEFINE_DECL:
				sequence_SizeDefineDecl(context, (SizeDefineDecl) semanticObject); 
				return; 
			case SpectraPackage.SUBRANGE:
				sequence_Subrange(context, (Subrange) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_ADDITIVE_EXPR:
				sequence_TemporalAdditiveExpr(context, (TemporalAdditiveExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_AND_EXPR:
				sequence_TemporalAndExpr(context, (TemporalAndExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_BINARY_EXPR:
				sequence_TemporalBinaryExpr(context, (TemporalBinaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IFF_EXPR:
				sequence_TemporalIffExpr(context, (TemporalIffExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IMP_EXPR:
				sequence_TemporalImpExpr(context, (TemporalImpExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IN_EXPR:
				sequence_TemporalInExpr(context, (TemporalInExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_MULTIPLICATIVE_EXPR:
				sequence_TemporalMultiplicativeExpr(context, (TemporalMultiplicativeExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_OR_EXPR:
				sequence_TemporalOrExpr(context, (TemporalOrExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_PRIMARY_EXPR:
				sequence_TemporalPrimaryExpr(context, (TemporalPrimaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_RELATIONAL_EXPR:
				sequence_TemporalRelationalExpr(context, (TemporalRelationalExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_REMAINDER_EXPR:
				sequence_TemporalRemainderExpr(context, (TemporalRemainderExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_UNARY_EXPR:
				sequence_TemporalUnaryExpr(context, (TemporalUnaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case SpectraPackage.TYPE_CONSTANT:
				sequence_TypeConstant(context, (TypeConstant) semanticObject); 
				return; 
			case SpectraPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case SpectraPackage.TYPED_PARAM:
				sequence_TypedParam(context, (TypedParam) semanticObject); 
				return; 
			case SpectraPackage.TYPED_PARAM_LIST:
				sequence_TypedParamList(context, (TypedParamList) semanticObject); 
				return; 
			case SpectraPackage.UNARY_REG_EXP:
				sequence_UnaryRegExp(context, (UnaryRegExp) semanticObject); 
				return; 
			case SpectraPackage.VALUE_IN_RANGE:
				sequence_ValueInRange(context, (ValueInRange) semanticObject); 
				return; 
			case SpectraPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case SpectraPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case SpectraPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			case SpectraPackage.WEIGHT_DEF:
				sequence_WeightDef(context, (WeightDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     RegExp returns BinaryRegExp
	 *     BinaryRegExp returns BinaryRegExp
	 *     BinaryRegExp.BinaryRegExp_1_0 returns BinaryRegExp
	 *     UnaryRegExp returns BinaryRegExp
	 *     UnaryRegExp.UnaryRegExp_1_0 returns BinaryRegExp
	 *     CompRegExp returns BinaryRegExp
	 *     PrimaryRegExp returns BinaryRegExp
	 *
	 * Constraint:
	 *     (left=BinaryRegExp_BinaryRegExp_1_0 (op='&' | op='|')? right=UnaryRegExp)
	 */
	protected void sequence_BinaryRegExp(ISerializationContext context, BinaryRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanTerm returns BooleanTerm
	 *
	 * Constraint:
	 *     relExpr=TemporalInExpr
	 */
	protected void sequence_BooleanTerm(ISerializationContext context, BooleanTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.BOOLEAN_TERM__REL_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.BOOLEAN_TERM__REL_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTermAccess().getRelExprTemporalInExprParserRuleCall_2_0(), semanticObject.getRelExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns CompRegExp
	 *     BinaryRegExp returns CompRegExp
	 *     BinaryRegExp.BinaryRegExp_1_0 returns CompRegExp
	 *     UnaryRegExp returns CompRegExp
	 *     UnaryRegExp.UnaryRegExp_1_0 returns CompRegExp
	 *     CompRegExp returns CompRegExp
	 *     PrimaryRegExp returns CompRegExp
	 *
	 * Constraint:
	 *     (comp='~' left=CompRegExp)
	 */
	protected void sequence_CompRegExp(ISerializationContext context, CompRegExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.COMP_REG_EXP__COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.COMP_REG_EXP__COMP));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REG_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REG_EXP__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompRegExpAccess().getCompTildeKeyword_1_1_0(), semanticObject.getComp());
		feeder.accept(grammarAccess.getCompRegExpAccess().getLeftCompRegExpParserRuleCall_1_2_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns Constant
	 *     TemporalInExpr returns Constant
	 *     TemporalInExpr.TemporalInExpr_1_0 returns Constant
	 *     TemporalImpExpr returns Constant
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns Constant
	 *     TemporalIffExpr returns Constant
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns Constant
	 *     TemporalOrExpr returns Constant
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns Constant
	 *     TemporalAndExpr returns Constant
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns Constant
	 *     TemporalRelationalExpr returns Constant
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns Constant
	 *     TemporalRemainderExpr returns Constant
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns Constant
	 *     TemporalAdditiveExpr returns Constant
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns Constant
	 *     TemporalMultiplicativeExpr returns Constant
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns Constant
	 *     TemporalBinaryExpr returns Constant
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns Constant
	 *     TemporalUnaryExpr returns Constant
	 *     TemporalPrimaryExpr returns Constant
	 *     Constant returns Constant
	 *     QuantifierExpr returns Constant
	 *
	 * Constraint:
	 *     (booleanValue='FALSE' | booleanValue='false' | booleanValue='TRUE' | booleanValue='true' | integerValue=INT)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Counter
	 *     Referrable returns Counter
	 *     Counter returns Counter
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         range=Subrange 
	 *         (
	 *             initial+=TemporalInExpr | 
	 *             resetPred+=TemporalInExpr | 
	 *             incPred+=TemporalExpression | 
	 *             decPred+=TemporalExpression | 
	 *             overflowMethod+=OverflowMethod | 
	 *             underflowMethod+=OverflowMethod
	 *         )*
	 *     )
	 */
	protected void sequence_Counter(ISerializationContext context, Counter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineArray returns DefineArray
	 *
	 * Constraint:
	 *     ((simpleExprs+=TemporalExpression simpleExprs+=TemporalExpression*) | (innerArrays+=DefineArray innerArrays+=DefineArray*))
	 */
	protected void sequence_DefineArray(ISerializationContext context, DefineArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DefineDecl
	 *     DefineDecl returns DefineDecl
	 *
	 * Constraint:
	 *     ((name=ID simpleExpr=TemporalExpression) | (name=ID dimensions+=SizeDefineDecl+ innerArray=DefineArray))
	 */
	protected void sequence_DefineDecl(ISerializationContext context, DefineDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DefineRegExpDecl
	 *     DefineRegExpDecl returns DefineRegExpDecl
	 *
	 * Constraint:
	 *     (name=ID exp=RegExp)
	 */
	protected void sequence_DefineRegExpDecl(ISerializationContext context, DefineRegExpDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.DEFINE_REG_EXP_DECL__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.DEFINE_REG_EXP_DECL__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefineRegExpDeclAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefineRegExpDeclAccess().getExpRegExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns DefineRegExp
	 *     DefineRegExp returns DefineRegExp
	 *
	 * Constraint:
	 *     defineRegsList+=DefineRegExpDecl+
	 */
	protected void sequence_DefineRegExp(ISerializationContext context, DefineRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Define
	 *     Define returns Define
	 *
	 * Constraint:
	 *     defineList+=DefineDecl+
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DomainVarDecl
	 *     DomainVarDecl returns DomainVarDecl
	 *
	 * Constraint:
	 *     (name=ID domainType=VarType)
	 */
	protected void sequence_DomainVarDecl(ISerializationContext context, DomainVarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.DOMAIN_VAR_DECL__DOMAIN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.DOMAIN_VAR_DECL__DOMAIN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainVarDeclAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDomainVarDeclAccess().getDomainTypeVarTypeParserRuleCall_2_0(), semanticObject.getDomainType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns EXGar
	 *     EXGar returns EXGar
	 *
	 * Constraint:
	 *     (name=ID? ((elements+=TemporalInExpr elements+=TemporalInExpr*) | regExpPointer=[DefineRegExpDecl|ID] | regExp=RegExp))
	 */
	protected void sequence_EXGar(ISerializationContext context, EXGar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns LTLAsm
	 *     LTLAsm returns LTLAsm
	 *
	 * Constraint:
	 *     (
	 *         (name=ID params=TypedParamList?)? 
	 *         (
	 *             (
	 *                 (
	 *                     safety='G' | 
	 *                     safety='trans' | 
	 *                     stateInv='always' | 
	 *                     stateInv='alw' | 
	 *                     justice='GF' | 
	 *                     justice='alwEv' | 
	 *                     justice='alwaysEventually'
	 *                 )? 
	 *                 temporalExpr=QuantifierExpr
	 *             ) | 
	 *             trig=Trigger
	 *         )
	 *     )
	 */
	protected void sequence_LTLAsm(ISerializationContext context, LTLAsm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns LTLGar
	 *     LTLGar returns LTLGar
	 *
	 * Constraint:
	 *     (
	 *         (name=ID params=TypedParamList?)? 
	 *         (
	 *             (
	 *                 (
	 *                     safety='G' | 
	 *                     safety='trans' | 
	 *                     stateInv='always' | 
	 *                     stateInv='alw' | 
	 *                     justice='GF' | 
	 *                     justice='alwEv' | 
	 *                     justice='alwaysEventually'
	 *                 )? 
	 *                 temporalExpr=QuantifierExpr
	 *             ) | 
	 *             trig=Trigger
	 *         )
	 *     )
	 */
	protected void sequence_LTLGar(ISerializationContext context, LTLGar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (imports+=Import* name=ID elements+=Decl+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Monitor
	 *     Referrable returns Monitor
	 *     Monitor returns Monitor
	 *
	 * Constraint:
	 *     (type=VarType name=ID (initial+=TemporalInExpr | safety+=TemporalInExpr | stateInv+=TemporalInExpr)*)
	 */
	protected void sequence_Monitor(ISerializationContext context, Monitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternParamList returns PatternParamList
	 *
	 * Constraint:
	 *     (params+=PatternParam params+=PatternParam*)
	 */
	protected void sequence_PatternParamList(ISerializationContext context, PatternParamList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns PatternParam
	 *     PatternParam returns PatternParam
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PatternParam(ISerializationContext context, PatternParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternParamAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Pattern
	 *     Pattern returns Pattern
	 *     PredicateOrPatternReferrable returns Pattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         params=PatternParamList? 
	 *         varDeclList+=VarDecl* 
	 *         (initial+=TemporalInExpr | safety+=TemporalInExpr | stateInv+=TemporalInExpr | justice+=TemporalInExpr)+
	 *     )
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Predicate
	 *     Predicate returns Predicate
	 *     PredicateOrPatternReferrable returns Predicate
	 *
	 * Constraint:
	 *     (name=ID params=TypedParamList? (body=TemporalExpression | body=TemporalExpression))
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExp
	 *     BinaryRegExp returns RegExp
	 *     BinaryRegExp.BinaryRegExp_1_0 returns RegExp
	 *     UnaryRegExp returns RegExp
	 *     UnaryRegExp.UnaryRegExp_1_0 returns RegExp
	 *     CompRegExp returns RegExp
	 *     PrimaryRegExp returns RegExp
	 *
	 * Constraint:
	 *     (
	 *         val='TRUE' | 
	 *         val='FALSE' | 
	 *         val='true' | 
	 *         val='false' | 
	 *         assrt=BooleanTerm | 
	 *         empty?='()'
	 *     )
	 */
	protected void sequence_PrimaryRegExp(ISerializationContext context, RegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns QuantifierExpr
	 *     TemporalInExpr returns QuantifierExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns QuantifierExpr
	 *     TemporalImpExpr returns QuantifierExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns QuantifierExpr
	 *     TemporalIffExpr returns QuantifierExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns QuantifierExpr
	 *     TemporalOrExpr returns QuantifierExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns QuantifierExpr
	 *     TemporalAndExpr returns QuantifierExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns QuantifierExpr
	 *     TemporalRelationalExpr returns QuantifierExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns QuantifierExpr
	 *     TemporalRemainderExpr returns QuantifierExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns QuantifierExpr
	 *     TemporalAdditiveExpr returns QuantifierExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns QuantifierExpr
	 *     TemporalMultiplicativeExpr returns QuantifierExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns QuantifierExpr
	 *     TemporalBinaryExpr returns QuantifierExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns QuantifierExpr
	 *     TemporalUnaryExpr returns QuantifierExpr
	 *     TemporalPrimaryExpr returns QuantifierExpr
	 *     QuantifierExpr returns QuantifierExpr
	 *
	 * Constraint:
	 *     ((operator='forall' | operator='exists') domainVar=DomainVarDecl temporalExpr=QuantifierExpr)
	 */
	protected void sequence_QuantifierExpr(ISerializationContext context, QuantifierExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SizeDefineDecl returns SizeDefineDecl
	 *
	 * Constraint:
	 *     (value=INT | name=[DefineDecl|ID] | arithExp=TemporalExpression)
	 */
	protected void sequence_SizeDefineDecl(ISerializationContext context, SizeDefineDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Subrange returns Subrange
	 *
	 * Constraint:
	 *     (from=SizeDefineDecl to=SizeDefineDecl)
	 */
	protected void sequence_Subrange(ISerializationContext context, Subrange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.SUBRANGE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.SUBRANGE__FROM));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.SUBRANGE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.SUBRANGE__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubrangeAccess().getFromSizeDefineDeclParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getSubrangeAccess().getToSizeDefineDeclParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalAdditiveExpr
	 *     TemporalInExpr returns TemporalAdditiveExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalImpExpr returns TemporalAdditiveExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalIffExpr returns TemporalAdditiveExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalOrExpr returns TemporalAdditiveExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalAndExpr returns TemporalAdditiveExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalRelationalExpr returns TemporalAdditiveExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalRemainderExpr returns TemporalAdditiveExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalAdditiveExpr returns TemporalAdditiveExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalMultiplicativeExpr returns TemporalAdditiveExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalBinaryExpr returns TemporalAdditiveExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalAdditiveExpr
	 *     TemporalUnaryExpr returns TemporalAdditiveExpr
	 *     TemporalPrimaryExpr returns TemporalAdditiveExpr
	 *     QuantifierExpr returns TemporalAdditiveExpr
	 *
	 * Constraint:
	 *     (elements+=TemporalAdditiveExpr_TemporalAdditiveExpr_1_0 (operator+='+' | operator+='-') elements+=TemporalMultiplicativeExpr)
	 */
	protected void sequence_TemporalAdditiveExpr(ISerializationContext context, TemporalAdditiveExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalAndExpr
	 *     TemporalInExpr returns TemporalAndExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalAndExpr
	 *     TemporalImpExpr returns TemporalAndExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalAndExpr
	 *     TemporalIffExpr returns TemporalAndExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalAndExpr
	 *     TemporalOrExpr returns TemporalAndExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalAndExpr
	 *     TemporalAndExpr returns TemporalAndExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalAndExpr
	 *     TemporalRelationalExpr returns TemporalAndExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalAndExpr
	 *     TemporalRemainderExpr returns TemporalAndExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalAndExpr
	 *     TemporalAdditiveExpr returns TemporalAndExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalAndExpr
	 *     TemporalMultiplicativeExpr returns TemporalAndExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalAndExpr
	 *     TemporalBinaryExpr returns TemporalAndExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalAndExpr
	 *     TemporalUnaryExpr returns TemporalAndExpr
	 *     TemporalPrimaryExpr returns TemporalAndExpr
	 *     QuantifierExpr returns TemporalAndExpr
	 *
	 * Constraint:
	 *     (elements+=TemporalAndExpr_TemporalAndExpr_1_0 (operator+='&' | operator+='and') elements+=TemporalRelationalExpr)
	 */
	protected void sequence_TemporalAndExpr(ISerializationContext context, TemporalAndExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalBinaryExpr
	 *     TemporalInExpr returns TemporalBinaryExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalImpExpr returns TemporalBinaryExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalIffExpr returns TemporalBinaryExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalOrExpr returns TemporalBinaryExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalAndExpr returns TemporalBinaryExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalRelationalExpr returns TemporalBinaryExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalRemainderExpr returns TemporalBinaryExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalAdditiveExpr returns TemporalBinaryExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalMultiplicativeExpr returns TemporalBinaryExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalBinaryExpr returns TemporalBinaryExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalBinaryExpr
	 *     TemporalUnaryExpr returns TemporalBinaryExpr
	 *     TemporalPrimaryExpr returns TemporalBinaryExpr
	 *     QuantifierExpr returns TemporalBinaryExpr
	 *
	 * Constraint:
	 *     (
	 *         elements+=TemporalBinaryExpr_TemporalBinaryExpr_1_0 
	 *         (operator+='S' | operator+='SINCE' | operator+='T' | operator+='TRIGGERED') 
	 *         elements+=TemporalUnaryExpr
	 *     )
	 */
	protected void sequence_TemporalBinaryExpr(ISerializationContext context, TemporalBinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalIffExpr
	 *     TemporalInExpr returns TemporalIffExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalIffExpr
	 *     TemporalImpExpr returns TemporalIffExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalIffExpr
	 *     TemporalIffExpr returns TemporalIffExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalIffExpr
	 *     TemporalOrExpr returns TemporalIffExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalIffExpr
	 *     TemporalAndExpr returns TemporalIffExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalIffExpr
	 *     TemporalRelationalExpr returns TemporalIffExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalIffExpr
	 *     TemporalRemainderExpr returns TemporalIffExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalIffExpr
	 *     TemporalAdditiveExpr returns TemporalIffExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalIffExpr
	 *     TemporalMultiplicativeExpr returns TemporalIffExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalIffExpr
	 *     TemporalBinaryExpr returns TemporalIffExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalIffExpr
	 *     TemporalUnaryExpr returns TemporalIffExpr
	 *     TemporalPrimaryExpr returns TemporalIffExpr
	 *     QuantifierExpr returns TemporalIffExpr
	 *
	 * Constraint:
	 *     (elements+=TemporalIffExpr_TemporalIffExpr_1_0 (operator='<->' | operator='iff') elements+=TemporalOrExpr)
	 */
	protected void sequence_TemporalIffExpr(ISerializationContext context, TemporalIffExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalImpExpr
	 *     TemporalInExpr returns TemporalImpExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalImpExpr
	 *     TemporalImpExpr returns TemporalImpExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalImpExpr
	 *     TemporalIffExpr returns TemporalImpExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalImpExpr
	 *     TemporalOrExpr returns TemporalImpExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalImpExpr
	 *     TemporalAndExpr returns TemporalImpExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalImpExpr
	 *     TemporalRelationalExpr returns TemporalImpExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalImpExpr
	 *     TemporalRemainderExpr returns TemporalImpExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalImpExpr
	 *     TemporalAdditiveExpr returns TemporalImpExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalImpExpr
	 *     TemporalMultiplicativeExpr returns TemporalImpExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalImpExpr
	 *     TemporalBinaryExpr returns TemporalImpExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalImpExpr
	 *     TemporalUnaryExpr returns TemporalImpExpr
	 *     TemporalPrimaryExpr returns TemporalImpExpr
	 *     QuantifierExpr returns TemporalImpExpr
	 *
	 * Constraint:
	 *     (left=TemporalImpExpr_TemporalImpExpr_1_0 (operator='->' | operator='implies') implication=TemporalImpExpr)
	 */
	protected void sequence_TemporalImpExpr(ISerializationContext context, TemporalImpExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalInExpr
	 *     TemporalInExpr returns TemporalInExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalInExpr
	 *     TemporalImpExpr returns TemporalInExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalInExpr
	 *     TemporalIffExpr returns TemporalInExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalInExpr
	 *     TemporalOrExpr returns TemporalInExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalInExpr
	 *     TemporalAndExpr returns TemporalInExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalInExpr
	 *     TemporalRelationalExpr returns TemporalInExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalInExpr
	 *     TemporalRemainderExpr returns TemporalInExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalInExpr
	 *     TemporalAdditiveExpr returns TemporalInExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalInExpr
	 *     TemporalMultiplicativeExpr returns TemporalInExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalInExpr
	 *     TemporalBinaryExpr returns TemporalInExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalInExpr
	 *     TemporalUnaryExpr returns TemporalInExpr
	 *     TemporalPrimaryExpr returns TemporalInExpr
	 *     QuantifierExpr returns TemporalInExpr
	 *
	 * Constraint:
	 *     (left=TemporalInExpr_TemporalInExpr_1_0 not?='not'? operator='in' values+=ValueInRange values+=ValueInRange*)
	 */
	protected void sequence_TemporalInExpr(ISerializationContext context, TemporalInExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalMultiplicativeExpr
	 *     TemporalInExpr returns TemporalMultiplicativeExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalImpExpr returns TemporalMultiplicativeExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalIffExpr returns TemporalMultiplicativeExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalOrExpr returns TemporalMultiplicativeExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalAndExpr returns TemporalMultiplicativeExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalRelationalExpr returns TemporalMultiplicativeExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalRemainderExpr returns TemporalMultiplicativeExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalAdditiveExpr returns TemporalMultiplicativeExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalMultiplicativeExpr returns TemporalMultiplicativeExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalBinaryExpr returns TemporalMultiplicativeExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalMultiplicativeExpr
	 *     TemporalUnaryExpr returns TemporalMultiplicativeExpr
	 *     TemporalPrimaryExpr returns TemporalMultiplicativeExpr
	 *     QuantifierExpr returns TemporalMultiplicativeExpr
	 *
	 * Constraint:
	 *     (elements+=TemporalMultiplicativeExpr_TemporalMultiplicativeExpr_1_0 (operator+='*' | operator+='/') elements+=TemporalBinaryExpr)
	 */
	protected void sequence_TemporalMultiplicativeExpr(ISerializationContext context, TemporalMultiplicativeExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalOrExpr
	 *     TemporalInExpr returns TemporalOrExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalOrExpr
	 *     TemporalImpExpr returns TemporalOrExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalOrExpr
	 *     TemporalIffExpr returns TemporalOrExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalOrExpr
	 *     TemporalOrExpr returns TemporalOrExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalOrExpr
	 *     TemporalAndExpr returns TemporalOrExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalOrExpr
	 *     TemporalRelationalExpr returns TemporalOrExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalOrExpr
	 *     TemporalRemainderExpr returns TemporalOrExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalOrExpr
	 *     TemporalAdditiveExpr returns TemporalOrExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalOrExpr
	 *     TemporalMultiplicativeExpr returns TemporalOrExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalOrExpr
	 *     TemporalBinaryExpr returns TemporalOrExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalOrExpr
	 *     TemporalUnaryExpr returns TemporalOrExpr
	 *     TemporalPrimaryExpr returns TemporalOrExpr
	 *     QuantifierExpr returns TemporalOrExpr
	 *
	 * Constraint:
	 *     (elements+=TemporalOrExpr_TemporalOrExpr_1_0 (operator+='|' | operator+='or' | operator+='xor') elements+=TemporalAndExpr)
	 */
	protected void sequence_TemporalOrExpr(ISerializationContext context, TemporalOrExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalPrimaryExpr
	 *     TemporalInExpr returns TemporalPrimaryExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalImpExpr returns TemporalPrimaryExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalIffExpr returns TemporalPrimaryExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalOrExpr returns TemporalPrimaryExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalAndExpr returns TemporalPrimaryExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalRelationalExpr returns TemporalPrimaryExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalRemainderExpr returns TemporalPrimaryExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalAdditiveExpr returns TemporalPrimaryExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalMultiplicativeExpr returns TemporalPrimaryExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalBinaryExpr returns TemporalPrimaryExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalPrimaryExpr
	 *     TemporalUnaryExpr returns TemporalPrimaryExpr
	 *     TemporalPrimaryExpr returns TemporalPrimaryExpr
	 *     QuantifierExpr returns TemporalPrimaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (predPatt=[PredicateOrPatternReferrable|ID] (predPattParams+=TemporalInExpr predPattParams+=TemporalInExpr*)?) | 
	 *         ((operator='-' | operator='!') tpe=TemporalPrimaryExpr) | 
	 *         (pointer=[Referrable|ID] index+=TemporalInExpr*) | 
	 *         (operator='next' temporalExpression=TemporalInExpr) | 
	 *         (operator='regexp' (regexp=RegExp | regexpPointer=[DefineRegExpDecl|ID])) | 
	 *         (pointer=[Referrable|ID] operator='.all') | 
	 *         (pointer=[Referrable|ID] operator='.any') | 
	 *         (pointer=[Referrable|ID] operator='.prod') | 
	 *         (pointer=[Referrable|ID] operator='.sum') | 
	 *         (pointer=[Referrable|ID] operator='.min') | 
	 *         (pointer=[Referrable|ID] operator='.max')
	 *     )
	 */
	protected void sequence_TemporalPrimaryExpr(ISerializationContext context, TemporalPrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalRelationalExpr
	 *     TemporalInExpr returns TemporalRelationalExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalImpExpr returns TemporalRelationalExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalIffExpr returns TemporalRelationalExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalOrExpr returns TemporalRelationalExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalAndExpr returns TemporalRelationalExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalRelationalExpr returns TemporalRelationalExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalRemainderExpr returns TemporalRelationalExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalAdditiveExpr returns TemporalRelationalExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalMultiplicativeExpr returns TemporalRelationalExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalBinaryExpr returns TemporalRelationalExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalRelationalExpr
	 *     TemporalUnaryExpr returns TemporalRelationalExpr
	 *     TemporalPrimaryExpr returns TemporalRelationalExpr
	 *     QuantifierExpr returns TemporalRelationalExpr
	 *
	 * Constraint:
	 *     (
	 *         left=TemporalRelationalExpr_TemporalRelationalExpr_1_0 
	 *         (
	 *             operator='=' | 
	 *             operator='!=' | 
	 *             operator='<' | 
	 *             operator='>' | 
	 *             operator='<=' | 
	 *             operator='>='
	 *         ) 
	 *         right=TemporalRemainderExpr
	 *     )
	 */
	protected void sequence_TemporalRelationalExpr(ISerializationContext context, TemporalRelationalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalRemainderExpr
	 *     TemporalInExpr returns TemporalRemainderExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalImpExpr returns TemporalRemainderExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalIffExpr returns TemporalRemainderExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalOrExpr returns TemporalRemainderExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalAndExpr returns TemporalRemainderExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalRelationalExpr returns TemporalRemainderExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalRemainderExpr returns TemporalRemainderExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalAdditiveExpr returns TemporalRemainderExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalMultiplicativeExpr returns TemporalRemainderExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalBinaryExpr returns TemporalRemainderExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalRemainderExpr
	 *     TemporalUnaryExpr returns TemporalRemainderExpr
	 *     TemporalPrimaryExpr returns TemporalRemainderExpr
	 *     QuantifierExpr returns TemporalRemainderExpr
	 *
	 * Constraint:
	 *     (left=TemporalRemainderExpr_TemporalRemainderExpr_1_0 (operator='mod' | operator='%') right=TemporalAdditiveExpr)
	 */
	protected void sequence_TemporalRemainderExpr(ISerializationContext context, TemporalRemainderExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalUnaryExpr
	 *     TemporalInExpr returns TemporalUnaryExpr
	 *     TemporalInExpr.TemporalInExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalImpExpr returns TemporalUnaryExpr
	 *     TemporalImpExpr.TemporalImpExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalIffExpr returns TemporalUnaryExpr
	 *     TemporalIffExpr.TemporalIffExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalOrExpr returns TemporalUnaryExpr
	 *     TemporalOrExpr.TemporalOrExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalAndExpr returns TemporalUnaryExpr
	 *     TemporalAndExpr.TemporalAndExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalRelationalExpr returns TemporalUnaryExpr
	 *     TemporalRelationalExpr.TemporalRelationalExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalRemainderExpr returns TemporalUnaryExpr
	 *     TemporalRemainderExpr.TemporalRemainderExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalAdditiveExpr returns TemporalUnaryExpr
	 *     TemporalAdditiveExpr.TemporalAdditiveExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalMultiplicativeExpr returns TemporalUnaryExpr
	 *     TemporalMultiplicativeExpr.TemporalMultiplicativeExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalBinaryExpr returns TemporalUnaryExpr
	 *     TemporalBinaryExpr.TemporalBinaryExpr_1_0 returns TemporalUnaryExpr
	 *     TemporalUnaryExpr returns TemporalUnaryExpr
	 *     TemporalPrimaryExpr returns TemporalUnaryExpr
	 *     QuantifierExpr returns TemporalUnaryExpr
	 *
	 * Constraint:
	 *     (
	 *         ((kinds='Y' | kinds='PREV') tue=TemporalUnaryExpr) | 
	 *         ((kinds='H' | kinds='HISTORICALLY') tue=TemporalUnaryExpr) | 
	 *         ((kinds='O' | kinds='ONCE') tue=TemporalUnaryExpr)
	 *     )
	 */
	protected void sequence_TemporalUnaryExpr(ISerializationContext context, TemporalUnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     ((initPointer=[DefineRegExpDecl|ID] | initRegExp=RegExp) (effectPointer=[DefineRegExpDecl|ID] | effectRegExp=RegExp))
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns TypeConstant
	 *     TypeConstant returns TypeConstant
	 *
	 * Constraint:
	 *     name=TypeConstantLiteral
	 */
	protected void sequence_TypeConstant(ISerializationContext context, TypeConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeConstantAccess().getNameTypeConstantLiteralParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID type=VarType)
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.TYPE_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.TYPE_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.TYPE_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.TYPE_DEF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDefAccess().getTypeVarTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedParamList returns TypedParamList
	 *
	 * Constraint:
	 *     (params+=TypedParam params+=TypedParam*)
	 */
	protected void sequence_TypedParamList(ISerializationContext context, TypedParamList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns TypedParam
	 *     TypedParam returns TypedParam
	 *
	 * Constraint:
	 *     (type=VarType name=ID)
	 */
	protected void sequence_TypedParam(ISerializationContext context, TypedParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.TYPED_PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.TYPED_PARAM__TYPE));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedParamAccess().getTypeVarTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTypedParamAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns UnaryRegExp
	 *     BinaryRegExp returns UnaryRegExp
	 *     BinaryRegExp.BinaryRegExp_1_0 returns UnaryRegExp
	 *     UnaryRegExp returns UnaryRegExp
	 *     UnaryRegExp.UnaryRegExp_1_0 returns UnaryRegExp
	 *     CompRegExp returns UnaryRegExp
	 *     PrimaryRegExp returns UnaryRegExp
	 *
	 * Constraint:
	 *     (
	 *         left=UnaryRegExp_UnaryRegExp_1_0 
	 *         (
	 *             kleened?='*' | 
	 *             questionMark?='?' | 
	 *             plus?='+' | 
	 *             (haveExactRepetition?='{' exactRepetition=INT) | 
	 *             (haveAtLeast?='{' atLeast=INT) | 
	 *             (haveRange?='{' (from=INT | fromDefine=[DefineDecl|ID]) (to=INT | toDefine=[DefineDecl|ID]))
	 *         )
	 *     )
	 */
	protected void sequence_UnaryRegExp(ISerializationContext context, UnaryRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueInRange returns ValueInRange
	 *
	 * Constraint:
	 *     (
	 *         const=[TypeConstant|ID] | 
	 *         int=INT | 
	 *         (from=INT multi?='-' to=INT) | 
	 *         booleanValue='TRUE' | 
	 *         booleanValue='FALSE' | 
	 *         booleanValue='true' | 
	 *         booleanValue='false'
	 *     )
	 */
	protected void sequence_ValueInRange(ISerializationContext context, ValueInRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns VarDecl
	 *     Referrable returns VarDecl
	 *
	 * Constraint:
	 *     (type=VarType name=ID)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.VAR_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.VAR_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclAccess().getTypeVarTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     ((name='boolean' | subr=Subrange | (const+=TypeConstant const+=TypeConstant*) | type=[TypeDef|ID]) dimensions+=SizeDefineDecl*)
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (kind=VarOwner var=VarDecl)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.VAR__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.VAR__KIND));
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.VAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.VAR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getKindVarOwnerEnumRuleCall_0_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getVarAccess().getVarVarDeclParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns WeightDef
	 *     WeightDef returns WeightDef
	 *
	 * Constraint:
	 *     (name=ID? negative='-'? value=INT definition=TemporalInExpr)
	 */
	protected void sequence_WeightDef(ISerializationContext context, WeightDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
